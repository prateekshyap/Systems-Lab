<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0-beta2) on Thu May 20 07:05:18 EDT 2004 -->
<TITLE>
FJTask
</TITLE>

<META NAME="keywords" CONTENT="EDU.oswego.cs.dl.util.concurrent.FJTask class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="FJTask";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FIFOSemaphore.FIFOWaitQueue.html" title="class in EDU.oswego.cs.dl.util.concurrent"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.Par.html" title="class in EDU.oswego.cs.dl.util.concurrent"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../../index.html?EDU/oswego/cs/dl/util/concurrent/FJTask.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="FJTask.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
EDU.oswego.cs.dl.util.concurrent</FONT>
<BR>
Class FJTask</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../../../resources/inherit.gif" ALT="extended by "><B>EDU.oswego.cs.dl.util.concurrent.FJTask</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Runnable</DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.Par.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask.Par</A>, <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.Par2.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask.Par2</A>, <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.Seq.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask.Seq</A>, <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.Seq2.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask.Seq2</A>, <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.Wrap.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask.Wrap</A>, <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup.InvokableFJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTaskRunnerGroup.InvokableFJTask</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>FJTask</B><DT>extends java.lang.Object<DT>implements java.lang.Runnable</DL>
</PRE>

<P>
Abstract base class for Fork/Join Tasks.

 <p>
 FJTasks are lightweight, stripped-down analogs of Threads. 
 Many FJTasks share the same pool of Java threads. This is
 supported by the FJTaskRunnerGroup and FJTaskRunner classes, that 
 mainly contain
 methods called only internally by FJTasks.
 FJTasks support versions of the most common methods found in class Thread,
 including start(), yield() and join(). However, they
 don't support priorities, ThreadGroups or other bookkeeping
 or control methods of class Thread.
 <p>
 FJTasks should normally be defined by subclassing and adding a run() method.
 Alternatively, static inner class <code>Wrap(Runnable r)</code> 
 can be used to
 wrap an existing Runnable object in a FJTask. 
 <p>
 <code>FJTaskRunnerGroup.execute(FJTask)</code> can be used to
 initiate a FJTask from a non-FJTask thread. 
 And <code>FJTaskRunnerGroup.invoke(FJTask)</code> can be used to initiate
 a FJTask and then wait for it to complete before returning.
 These are the only entry-points from normal threads to FJTasks.
 Most FJTask methods themselves may only be called from within running FJTasks.
 They throw ClassCastExceptions if they are not, 
 reflecting the fact that these methods
 can only be executed using FJTaskRunner threads, not generic
 java.lang.Threads.
 <p>
 There are three different ways to run a FJTask,
 with different scheduling semantics:
 <ul>
   <li> FJTask.start() (as well as FJTaskRunnerGroup.execute(FJTask)) 
         behaves pretty much like Thread.start(). It enqueues a task to be
         run the next time any FJTaskRunner thread is otherwise idle.
         It maintains standard FIFO ordering with respect to
         the group of worker threads.
   <li> FJTask.fork() (as well as the two-task spawning method,
         coInvoke(task1, task2), and the array version 
         coInvoke(FJTask[] tasks)) starts a task 
         that will be executed in
         procedure-call-like LIFO order if executed by the 
         same worker thread as the one that created it, but is FIFO 
         with respect to other tasks if it is run by
         other worker threads. That is, earlier-forked
         tasks are preferred to later-forked tasks by other idle workers.
         Fork() is noticeably faster than start(), but can only be
         used when these scheduling semantics are acceptable.
   <li> FJTask.invoke(FJTask) just executes the run method
        of one task from within another. It is the analog of a
        direct call.
 </ul>
 <p>
 The main economies of FJTasks stem from the fact that
 FJTasks do not support blocking operations of any kind. 
 FJTasks should just run to completion without
 issuing waits or performing blocking IO. 
 There are several styles for creating the run methods that
 execute as tasks, including
 event-style methods, and pure computational methods.
 Generally, the best kinds of FJTasks are those that in turn
 generate other FJTasks. 
 <p>
 There is nothing actually
 preventing you from blocking within a FJTask, and very short waits/blocks are
 completely well behaved. But FJTasks are not designed
 to support arbitrary synchronization 
 since there is no way to suspend and resume individual tasks
 once they have begun executing. FJTasks should also be finite
 in duration -- they should not contain infinite loops.
 FJTasks that might need to perform a blocking
 action, or hold locks for extended periods, or 
 loop forever can instead create normal 
 java Thread objects that will do so. FJTasks are just not
 designed to support these things. 
 FJTasks may however yield() control to allow their FJTaskRunner threads
 to run other tasks,
 and may wait for other dependent tasks via join(). These
 are the only coordination mechanisms supported by FJTasks.
 <p>
 FJTasks, and the FJTaskRunners that execute them are not
 intrinsically robust with respect to exceptions. 
 A FJTask that aborts via an exception does not automatically
 have its completion flag (isDone) set. 
 As with ordinary Threads, an uncaught exception will normally cause
 its FJTaskRunner thread to die, which in turn may sometimes
 cause other computations being performed to hang or abort.
 You can of course
 do better by trapping exceptions inside the run methods of FJTasks.
 <p>
 The overhead differences between FJTasks and Threads are substantial,
 especially when using fork() or coInvoke().
 FJTasks can be two or three orders of magnitude faster than Threads,
 at least when run on JVMs with high-performance garbage collection
 (every FJTask quickly becomes garbage) and good native thread support.
 <p>
 Given these overhead savings, you might be tempted to use FJTasks for 
 everything you would use a normal Thread to do. Don't. Java Threads
 remain better for general purpose thread-based programming. Remember
 that FJTasks cannot be used for designs involving arbitrary blocking 
 synchronization or I/O. Extending FJTasks to support such capabilities
 would amount to re-inventing the Thread class, and would make them
 less optimal in the contexts that they were designed for.
 <p>[<a href="http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html"> Introduction to this package. </a>]
 <p>
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTaskRunner.html" title="class in EDU.oswego.cs.dl.util.concurrent"><CODE>FJTaskRunner</CODE></A>, 
<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup.html" title="class in EDU.oswego.cs.dl.util.concurrent"><CODE>FJTaskRunnerGroup</CODE></A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.Par.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask.Par</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A <code>new Par</code>, when executed,
 runs the tasks provided in the constructor in parallel using 
 coInvoke(tasks).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.Par2.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask.Par2</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A <code>new Par(task1, task2)</code>, when executed,
 runs task1 and task2 in parallel using coInvoke(task1, task2).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.Seq.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask.Seq</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A  <code>new Seq</code>, when executed,
 invokes each task provided in the constructor,  in order.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.Seq2.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask.Seq2</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A  <code>new Seq2(task1, task2)</code>, when executed,
 invokes task1 and then task2, in order.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.Wrap.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask.Wrap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A FJTask that holds a Runnable r, and calls r.run when executed.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#FJTask()">FJTask</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#cancel()">cancel</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the termination status of this task.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#coInvoke(EDU.oswego.cs.dl.util.concurrent.FJTask[])">coInvoke</A></B>(<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>[]&nbsp;tasks)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fork all tasks in array, and await their completion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#coInvoke(EDU.oswego.cs.dl.util.concurrent.FJTask, EDU.oswego.cs.dl.util.concurrent.FJTask)">coInvoke</A></B>(<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>&nbsp;task1,
         <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>&nbsp;task2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fork both tasks and then wait for their completion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#fork()">fork</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arrange for execution of a strictly dependent task.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTaskRunner.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTaskRunner</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#getFJTaskRunner()">getFJTaskRunner</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the FJTaskRunner thread running the current FJTask.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTaskRunnerGroup</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#getFJTaskRunnerGroup()">getFJTaskRunnerGroup</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the FJTaskRunnerGroup of the thread running the current FJTask.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#invoke(EDU.oswego.cs.dl.util.concurrent.FJTask)">invoke</A></B>(<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Immediately execute task t by calling its run method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#isDone()">isDone</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return true if current task has terminated or been cancelled.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#join()">join</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yield until this task isDone.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#par(EDU.oswego.cs.dl.util.concurrent.FJTask[])">par</A></B>(<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>[]&nbsp;tasks)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct and return a FJTask object that, when executed, will
 invoke the tasks in the tasks array in parallel using coInvoke</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#par(EDU.oswego.cs.dl.util.concurrent.FJTask, EDU.oswego.cs.dl.util.concurrent.FJTask)">par</A></B>(<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>&nbsp;task1,
    <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>&nbsp;task2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct and return a FJTask object that, when executed, will
 invoke task1 and task2, in parallel</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#reset()">reset</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clear the termination status of this task.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#seq(EDU.oswego.cs.dl.util.concurrent.FJTask[])">seq</A></B>(<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>[]&nbsp;tasks)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct and return a FJTask object that, when executed, will
 invoke the tasks in the tasks array in array order</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#seq(EDU.oswego.cs.dl.util.concurrent.FJTask, EDU.oswego.cs.dl.util.concurrent.FJTask)">seq</A></B>(<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>&nbsp;task1,
    <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>&nbsp;task2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct and return a FJTask object that, when executed, will
 invoke task1 and task2, in order</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#setDone()">setDone</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicate termination.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#start()">start</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Execute this task.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html#yield()">yield</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allow the current underlying FJTaskRunner thread to process other tasks.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Runnable"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from interface java.lang.Runnable</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>run</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="FJTask()"><!-- --></A><H3>
FJTask</H3>
<PRE>
public <B>FJTask</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getFJTaskRunner()"><!-- --></A><H3>
getFJTaskRunner</H3>
<PRE>
public static <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTaskRunner.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTaskRunner</A> <B>getFJTaskRunner</B>()</PRE>
<DL>
<DD>Return the FJTaskRunner thread running the current FJTask.
 Most FJTask methods are just relays to their current
 FJTaskRunners, that perform the indicated actions.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if caller thread is not a
 running FJTask.</DL>
</DD>
</DL>
<HR>

<A NAME="getFJTaskRunnerGroup()"><!-- --></A><H3>
getFJTaskRunnerGroup</H3>
<PRE>
public static <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTaskRunnerGroup</A> <B>getFJTaskRunnerGroup</B>()</PRE>
<DL>
<DD>Return the FJTaskRunnerGroup of the thread running the current FJTask.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if caller thread is not a
 running FJTask.</DL>
</DD>
</DL>
<HR>

<A NAME="isDone()"><!-- --></A><H3>
isDone</H3>
<PRE>
public final boolean <B>isDone</B>()</PRE>
<DL>
<DD>Return true if current task has terminated or been cancelled.
 The  method is a simple analog of the Thread.isAlive()
 method. However, it reports true only when the task has terminated
 or has been cancelled. It does not distinguish these two cases.
 And there is no way to determine whether a FJTask has been started
 or is currently executing.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDone()"><!-- --></A><H3>
setDone</H3>
<PRE>
protected final void <B>setDone</B>()</PRE>
<DL>
<DD>Indicate termination. Intended only to be called by FJTaskRunner.
 FJTasks themselves should use (non-final) method
 cancel() to suppress execution.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cancel()"><!-- --></A><H3>
cancel</H3>
<PRE>
public void <B>cancel</B>()</PRE>
<DL>
<DD>Set the termination status of this task. This simple-minded
 analog of Thread.interrupt
 causes the task not to execute if it has not already been started.
 Cancelling a running FJTask
 has no effect unless the run method itself uses isDone()
 to probe cancellation and take appropriate action.
 Individual run() methods may sense status and
 act accordingly, normally by returning early.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reset()"><!-- --></A><H3>
reset</H3>
<PRE>
public void <B>reset</B>()</PRE>
<DL>
<DD>Clear the termination status of this task. 
 This method is intended to be used
 only as a means to allow task objects to be recycled. It should
 be called only when you are sure that the previous
 execution of this task has terminated and, if applicable, has
 been joined by all other waiting tasks. Usage in any other
 context is a very bad idea.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="start()"><!-- --></A><H3>
start</H3>
<PRE>
public void <B>start</B>()</PRE>
<DL>
<DD>Execute this task. This method merely places the task in a 
 group-wide scheduling queue.
 It will be run 
 the next time any TaskRunner thread is otherwise idle.
 This scheduling  maintains FIFO ordering of started tasks 
 with respect to
 the group of worker threads.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if caller thread is not
 running in a FJTaskRunner thread.</DL>
</DD>
</DL>
<HR>

<A NAME="fork()"><!-- --></A><H3>
fork</H3>
<PRE>
public void <B>fork</B>()</PRE>
<DL>
<DD>Arrange for execution of a strictly dependent task.
 The task that will be executed in
 procedure-call-like LIFO order if executed by the 
 same worker thread, but is FIFO with respect to other tasks
 forked by this thread when taken by other worker threads. 
 That is, earlier-forked
 tasks are preferred to later-forked tasks by other idle workers.
 <p>
 Fork() is noticeably
 faster than start(). However, it may only
 be used for strictly dependent tasks -- generally, those that
 could logically be issued as straight method calls without 
 changing the logic of the program.
 The method is optimized for use in parallel fork/join designs
 in which the thread that issues one or more forks
 cannot continue until at least some of the forked 
 threads terminate and are joined.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if caller thread is not
 running in a FJTaskRunner thread.</DL>
</DD>
</DL>
<HR>

<A NAME="yield()"><!-- --></A><H3>
yield</H3>
<PRE>
public static void <B>yield</B>()</PRE>
<DL>
<DD>Allow the current underlying FJTaskRunner thread to process other tasks.
 <p>
 Spinloops based on yield() are well behaved so long
 as the event or condition being waited for is produced via another
 FJTask. Additionally, you must never hold a lock
 while performing a yield or join. (This is because
 multiple FJTasks can be run by the same Thread during
 a yield. Since java locks are held per-thread, the lock would not
 maintain the conceptual exclusion you have in mind.)
 <p>
 Otherwise, spinloops using
 yield are the main construction of choice when a task must wait
 for a condition that it is sure will eventually occur because it
 is being produced by some other FJTask.  The most common
 such condition is built-in: join() repeatedly yields until a task
 has terminated after producing some needed results. You can also
 use yield to wait for callbacks from other FJTasks, to wait for
 status flags to be set, and so on. However, in all these cases,
 you should be confident that the condition being waited for will
 occur, essentially always because it is produced by 
 a FJTask generated by the current task, or one of its subtasks.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if caller thread is not
 running in a FJTaskRunner thread.</DL>
</DD>
</DL>
<HR>

<A NAME="join()"><!-- --></A><H3>
join</H3>
<PRE>
public void <B>join</B>()</PRE>
<DL>
<DD>Yield until this task isDone.
 Equivalent to <code>while(!isDone()) yield(); </code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if caller thread is not
 running in a FJTaskRunner thread.</DL>
</DD>
</DL>
<HR>

<A NAME="invoke(EDU.oswego.cs.dl.util.concurrent.FJTask)"><!-- --></A><H3>
invoke</H3>
<PRE>
public static void <B>invoke</B>(<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>&nbsp;t)</PRE>
<DL>
<DD>Immediately execute task t by calling its run method. Has no
 effect if t has already been run or has been cancelled.
 It is equivalent to  calling t.run except that it
 deals with completion status, so should always be used
 instead of directly calling run.
 The method can be useful
 when a computation has been packaged as a FJTask, but you just need to 
 directly execute its body from within some other task.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="coInvoke(EDU.oswego.cs.dl.util.concurrent.FJTask, EDU.oswego.cs.dl.util.concurrent.FJTask)"><!-- --></A><H3>
coInvoke</H3>
<PRE>
public static void <B>coInvoke</B>(<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>&nbsp;task1,
                            <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>&nbsp;task2)</PRE>
<DL>
<DD>Fork both tasks and then wait for their completion. It behaves as:
 <pre>
 task1.fork(); task2.fork(); task2.join(); task1.join();
 </pre>
 As a simple classic example, here is
 a class that computes the Fibonacci function:
 <pre>
 public class Fib extends FJTask {
 
  // Computes fibonacci(n) = fibonacci(n-1) + fibonacci(n-2);  for n> 1
  //          fibonacci(0) = 0; 
  //          fibonacci(1) = 1.       

  // Value to compute fibonacci function for.
  // It is replaced with the answer when computed.
  private volatile int number;

  public Fib(int n) { number = n; }

  public int getAnswer() {
    if (!isDone()) throw new Error("Not yet computed");
    return number;
  }

  public void run() {
    int n = number;
    if (n > 1) {
      Fib f1 = new Fib(n - 1);
      Fib f2 = new Fib(n - 2);

      coInvoke(f1, f2); // run these in parallel

      // we know f1 and f2 are computed, so just directly access numbers
      number = f1.number + f2.number;
    }
  }

  public static void main(String[] args) { // sample driver
    try {
      int groupSize = 2;    // 2 worker threads
      int num = 35;         // compute fib(35)
      FJTaskRunnerGroup group = new FJTaskRunnerGroup(groupSize);
      Fib f = new Fib(num);
      group.invoke(f);
      int result = f.getAnswer();
      System.out.println(" Answer: " + result);
    }
    catch (InterruptedException ex) {
      System.out.println("Interrupted");
    }
  }
 }
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if caller thread is not 
 running in a FJTaskRunner thread.</DL>
</DD>
</DL>
<HR>

<A NAME="coInvoke(EDU.oswego.cs.dl.util.concurrent.FJTask[])"><!-- --></A><H3>
coInvoke</H3>
<PRE>
public static void <B>coInvoke</B>(<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>[]&nbsp;tasks)</PRE>
<DL>
<DD>Fork all tasks in array, and await their completion.
 Behaviorally equivalent to:
 <pre>
 for (int i = 0; i &lt; tasks.length; ++i) tasks[i].fork();
 for (int i = 0; i &lt; tasks.length; ++i) tasks[i].join();
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="seq(EDU.oswego.cs.dl.util.concurrent.FJTask[])"><!-- --></A><H3>
seq</H3>
<PRE>
public static <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A> <B>seq</B>(<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>[]&nbsp;tasks)</PRE>
<DL>
<DD>Construct and return a FJTask object that, when executed, will
 invoke the tasks in the tasks array in array order
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="par(EDU.oswego.cs.dl.util.concurrent.FJTask[])"><!-- --></A><H3>
par</H3>
<PRE>
public static <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A> <B>par</B>(<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>[]&nbsp;tasks)</PRE>
<DL>
<DD>Construct and return a FJTask object that, when executed, will
 invoke the tasks in the tasks array in parallel using coInvoke
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="seq(EDU.oswego.cs.dl.util.concurrent.FJTask, EDU.oswego.cs.dl.util.concurrent.FJTask)"><!-- --></A><H3>
seq</H3>
<PRE>
public static <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A> <B>seq</B>(<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>&nbsp;task1,
                         <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>&nbsp;task2)</PRE>
<DL>
<DD>Construct and return a FJTask object that, when executed, will
 invoke task1 and task2, in order
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="par(EDU.oswego.cs.dl.util.concurrent.FJTask, EDU.oswego.cs.dl.util.concurrent.FJTask)"><!-- --></A><H3>
par</H3>
<PRE>
public static <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A> <B>par</B>(<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>&nbsp;task1,
                         <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.html" title="class in EDU.oswego.cs.dl.util.concurrent">FJTask</A>&nbsp;task2)</PRE>
<DL>
<DD>Construct and return a FJTask object that, when executed, will
 invoke task1 and task2, in parallel
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FIFOSemaphore.FIFOWaitQueue.html" title="class in EDU.oswego.cs.dl.util.concurrent"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/FJTask.Par.html" title="class in EDU.oswego.cs.dl.util.concurrent"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../../index.html?EDU/oswego/cs/dl/util/concurrent/FJTask.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="FJTask.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
