<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0-beta2) on Thu May 20 07:05:10 EDT 2004 -->
<TITLE>
Channel
</TITLE>

<META NAME="keywords" CONTENT="EDU.oswego.cs.dl.util.concurrent.Channel interface">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Channel";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Callable.html" title="interface in EDU.oswego.cs.dl.util.concurrent"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/ClockDaemon.html" title="class in EDU.oswego.cs.dl.util.concurrent"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../../index.html?EDU/oswego/cs/dl/util/concurrent/Channel.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Channel.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
EDU.oswego.cs.dl.util.concurrent</FONT>
<BR>
Interface Channel</H2>
<DL>
<DT><B>All Superinterfaces:</B> <DD><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Puttable.html" title="interface in EDU.oswego.cs.dl.util.concurrent">Puttable</A>, <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Takable.html" title="interface in EDU.oswego.cs.dl.util.concurrent">Takable</A></DD>
</DL>
<DL>
<DT><B>All Known Subinterfaces:</B> <DD><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/BoundedChannel.html" title="interface in EDU.oswego.cs.dl.util.concurrent">BoundedChannel</A></DD>
</DL>
<DL>
<DT><B>All Known Implementing Classes:</B> <DD><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/BoundedBuffer.html" title="class in EDU.oswego.cs.dl.util.concurrent">BoundedBuffer</A>, <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/BoundedLinkedQueue.html" title="class in EDU.oswego.cs.dl.util.concurrent">BoundedLinkedQueue</A>, <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/BoundedPriorityQueue.html" title="class in EDU.oswego.cs.dl.util.concurrent">BoundedPriorityQueue</A>, <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/LinkedQueue.html" title="class in EDU.oswego.cs.dl.util.concurrent">LinkedQueue</A>, <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/SemaphoreControlledChannel.html" title="class in EDU.oswego.cs.dl.util.concurrent">SemaphoreControlledChannel</A>, <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Slot.html" title="class in EDU.oswego.cs.dl.util.concurrent">Slot</A>, <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/SynchronousChannel.html" title="class in EDU.oswego.cs.dl.util.concurrent">SynchronousChannel</A>, <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/WaitFreeQueue.html" title="class in EDU.oswego.cs.dl.util.concurrent">WaitFreeQueue</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public interface <B>Channel</B><DT>extends <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Puttable.html" title="interface in EDU.oswego.cs.dl.util.concurrent">Puttable</A>, <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Takable.html" title="interface in EDU.oswego.cs.dl.util.concurrent">Takable</A></DL>
</PRE>

<P>
Main interface for buffers, queues, pipes, conduits, etc.
 <p>
 A Channel represents anything that you can put items
 into and take them out of. As with the Sync 
 interface, both
 blocking (put(x), take),
 and timeouts (offer(x, msecs), poll(msecs)) policies
 are provided. Using a
 zero timeout for offer and poll results in a pure balking policy.
 <p>
 To aid in efforts to use Channels in a more typesafe manner,
 this interface extends Puttable and Takable. You can restrict
 arguments of instance variables to this type as a way of
 guaranteeing that producers never try to take, or consumers put.
 for example:
 <pre>
 class Producer implements Runnable {
   final Puttable chan;
   Producer(Puttable channel) { chan = channel; }
   public void run() {
     try {
       for(;;) { chan.put(produce()); }
     }
     catch (InterruptedException ex) {}
   }
   Object produce() { ... }
 }


 class Consumer implements Runnable {
   final Takable chan;
   Consumer(Takable channel) { chan = channel; }
   public void run() {
     try {
       for(;;) { consume(chan.take()); }
     }
     catch (InterruptedException ex) {}
   }
   void consume(Object x) { ... }
 }

 class Setup {
   void main() {
     Channel chan = new SomeChannelImplementation();
     Producer p = new Producer(chan);
     Consumer c = new Consumer(chan);
     new Thread(p).start();
     new Thread(c).start();
   }
 }
 </pre>
 <p>
 A given channel implementation might or might not have bounded
 capacity or other insertion constraints, so in general, you cannot tell if
 a given put will block. However,
 Channels that are designed to 
 have an element capacity (and so always block when full)
 should implement the 
 BoundedChannel 
 subinterface.
 <p>
 Channels may hold any kind of item. However,
 insertion of null is not in general supported. Implementations
 may (all currently do) throw IllegalArgumentExceptions upon attempts to
 insert null. 
 <p>
 By design, the Channel interface does not support any methods to determine
 the current number of elements being held in the channel.
 This decision reflects the fact that in
 concurrent programming, such methods are so rarely useful
 that including them invites misuse; at best they could 
 provide a snapshot of current
 state, that could change immediately after being reported.
 It is better practice to instead use poll and offer to try
 to take and put elements without blocking. For example,
 to empty out the current contents of a channel, you could write:
 <pre>
  try {
    for (;;) {
       Object item = channel.poll(0);
       if (item != null)
         process(item);
       else
         break;
    }
  }
  catch(InterruptedException ex) { ... }
 </pre>
 <p>
 However, it is possible to determine whether an item
 exists in a Channel via <code>peek</code>, which returns
 but does NOT remove the next item that can be taken (or null
 if there is no such item). The peek operation has a limited
 range of applicability, and must be used with care. Unless it
 is known that a given thread is the only possible consumer
 of a channel, and that no time-out-based <code>offer</code> operations
 are ever invoked, there is no guarantee that the item returned
 by peek will be available for a subsequent take.
 <p>
 When appropriate, you can define an isEmpty method to
 return whether <code>peek</code> returns null.
 <p>
 Also, as a compromise, even though it does not appear in interface,
 implementation classes that can readily compute the number
 of elements support a <code>size()</code> method. This allows careful
 use, for example in queue length monitors, appropriate to the
 particular implementation constraints and properties.
 <p>
 All channels allow multiple producers and/or consumers.
 They do not support any kind of <em>close</em> method
 to shut down operation or indicate completion of particular
 producer or consumer threads. 
 If you need to signal completion, one way to do it is to
 create a class such as
 <pre>
 class EndOfStream { 
    // Application-dependent field/methods
 }
 </pre>
 And to have producers put an instance of this class into
 the channel when they are done. The consumer side can then
 check this via
 <pre>
   Object x = aChannel.take();
   if (x instanceof EndOfStream) 
     // special actions; perhaps terminate
   else
     // process normally
 </pre>
 <p>
 In time-out based methods (poll(msecs) and offer(x, msecs), 
 time bounds are interpreted in
 a coarse-grained, best-effort fashion. Since there is no
 way in Java to escape out of a wait for a synchronized
 method/block, time bounds can sometimes be exceeded when
 there is a lot contention for the channel. Additionally,
 some Channel semantics entail a ``point of
 no return'' where, once some parts of the operation have completed,
 others must follow, regardless of time bound.
 <p>
 Interruptions are in general handled as early as possible
 in all methods. Normally, InterruptionExceptions are thrown
 in put/take and offer(msec)/poll(msec) if interruption
 is detected upon entry to the method, as well as in any
 later context surrounding waits. 
 <p>
 If a put returns normally, an offer
 returns true, or a put or poll returns non-null, the operation
 completed successfully. 
 In all other cases, the operation fails cleanly -- the
 element is not put or taken.
 <p>
 As with Sync classes, spinloops are not directly supported,
 are not particularly recommended for routine use, but are not hard 
 to construct. For example, here is an exponential backoff version:
 <pre>
 Object backOffTake(Channel q) throws InterruptedException {
   long waitTime = 0;
   for (;;) {
      Object x = q.poll(0);
      if (x != null)
        return x;
      else {
        Thread.sleep(waitTime);
        waitTime = 3 * waitTime / 2 + 1;
      }
    }
 </pre>
 <p>
 <b>Sample Usage</b>. Here is a producer/consumer design
 where the channel is used to hold Runnable commands representing
 background tasks.
 <pre>
 class Service {
   private final Channel channel = ... some Channel implementation;
  
   private void backgroundTask(int taskParam) { ... }

   public void action(final int arg) {
     Runnable command = 
       new Runnable() {
         public void run() { backgroundTask(arg); }
       };
     try { channel.put(command) }
     catch (InterruptedException ex) {
       Thread.currentThread().interrupt(); // ignore but propagate
     }
   }
 
   public Service() {
     Runnable backgroundLoop = 
       new Runnable() {
         public void run() {
           for (;;) {
             try {
               Runnable task = (Runnable)(channel.take());
               task.run();
             }
             catch (InterruptedException ex) { return; }
           }
         }
       };
     new Thread(backgroundLoop).start();
   }
 }
    
 </pre>
 <p>[<a href="http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html"> Introduction to this package. </a>]
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Sync.html" title="interface in EDU.oswego.cs.dl.util.concurrent"><CODE>Sync</CODE></A>, 
<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/BoundedChannel.html" title="interface in EDU.oswego.cs.dl.util.concurrent"><CODE>BoundedChannel</CODE></A></DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Channel.html#offer(java.lang.Object, long)">offer</A></B>(java.lang.Object&nbsp;item,
      long&nbsp;msecs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Place item in channel only if it can be accepted within
 msecs milliseconds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Channel.html#peek()">peek</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return, but do not remove object at head of Channel,
 or null if it is empty.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Channel.html#poll(long)">poll</A></B>(long&nbsp;msecs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return and remove an item from channel only if one is available within
 msecs milliseconds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Channel.html#put(java.lang.Object)">put</A></B>(java.lang.Object&nbsp;item)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Place item in the channel, possibly waiting indefinitely until
 it can be accepted.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Channel.html#take()">take</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return and remove an item from channel, 
 possibly waiting indefinitely until
 such an item exists.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="put(java.lang.Object)"><!-- --></A><H3>
put</H3>
<PRE>
void <B>put</B>(java.lang.Object&nbsp;item)
         throws java.lang.InterruptedException</PRE>
<DL>
<DD>Place item in the channel, possibly waiting indefinitely until
 it can be accepted. Channels implementing the BoundedChannel
 subinterface are generally guaranteed to block on puts upon
 reaching capacity, but other implementations may or may not block.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Puttable.html#put(java.lang.Object)">put</A></CODE> in interface <CODE><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Puttable.html" title="interface in EDU.oswego.cs.dl.util.concurrent">Puttable</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>item</CODE> - the element to be inserted. Should be non-null.
<DT><B>Throws:</B>
<DD><CODE>java.lang.InterruptedException</CODE> - if the current thread has
 been interrupted at a point at which interruption
 is detected, in which case the element is guaranteed not
 to be inserted. Otherwise, on normal return, the element is guaranteed
 to have been inserted.</DL>
</DD>
</DL>
<HR>

<A NAME="offer(java.lang.Object, long)"><!-- --></A><H3>
offer</H3>
<PRE>
boolean <B>offer</B>(java.lang.Object&nbsp;item,
              long&nbsp;msecs)
              throws java.lang.InterruptedException</PRE>
<DL>
<DD>Place item in channel only if it can be accepted within
 msecs milliseconds. The time bound is interpreted in
 a coarse-grained, best-effort fashion.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Puttable.html#offer(java.lang.Object, long)">offer</A></CODE> in interface <CODE><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Puttable.html" title="interface in EDU.oswego.cs.dl.util.concurrent">Puttable</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>item</CODE> - the element to be inserted. Should be non-null.<DD><CODE>msecs</CODE> - the number of milliseconds to wait. If less than
 or equal to zero, the method does not perform any timed waits,
 but might still require
 access to a synchronization lock, which can impose unbounded
 delay if there is a lot of contention for the channel.
<DT><B>Returns:</B><DD>true if accepted, else false
<DT><B>Throws:</B>
<DD><CODE>java.lang.InterruptedException</CODE> - if the current thread has
 been interrupted at a point at which interruption
 is detected, in which case the element is guaranteed not
 to be inserted (i.e., is equivalent to a false return).</DL>
</DD>
</DL>
<HR>

<A NAME="take()"><!-- --></A><H3>
take</H3>
<PRE>
java.lang.Object <B>take</B>()
                      throws java.lang.InterruptedException</PRE>
<DL>
<DD>Return and remove an item from channel, 
 possibly waiting indefinitely until
 such an item exists.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Takable.html#take()">take</A></CODE> in interface <CODE><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Takable.html" title="interface in EDU.oswego.cs.dl.util.concurrent">Takable</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>some item from the channel. Different implementations
  may guarantee various properties (such as FIFO) about that item
<DT><B>Throws:</B>
<DD><CODE>java.lang.InterruptedException</CODE> - if the current thread has
 been interrupted at a point at which interruption
 is detected, in which case state of the channel is unchanged.</DL>
</DD>
</DL>
<HR>

<A NAME="poll(long)"><!-- --></A><H3>
poll</H3>
<PRE>
java.lang.Object <B>poll</B>(long&nbsp;msecs)
                      throws java.lang.InterruptedException</PRE>
<DL>
<DD>Return and remove an item from channel only if one is available within
 msecs milliseconds. The time bound is interpreted in a coarse
 grained, best-effort fashion.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Takable.html#poll(long)">poll</A></CODE> in interface <CODE><A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Takable.html" title="interface in EDU.oswego.cs.dl.util.concurrent">Takable</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>msecs</CODE> - the number of milliseconds to wait. If less than
  or equal to zero, the operation does not perform any timed waits,
 but might still require
 access to a synchronization lock, which can impose unbounded
 delay if there is a lot of contention for the channel.
<DT><B>Returns:</B><DD>some item, or null if the channel is empty.
<DT><B>Throws:</B>
<DD><CODE>java.lang.InterruptedException</CODE> - if the current thread has
 been interrupted at a point at which interruption
 is detected, in which case state of the channel is unchanged
 (i.e., equivalent to a null return).</DL>
</DD>
</DL>
<HR>

<A NAME="peek()"><!-- --></A><H3>
peek</H3>
<PRE>
java.lang.Object <B>peek</B>()</PRE>
<DL>
<DD>Return, but do not remove object at head of Channel,
 or null if it is empty.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/Callable.html" title="interface in EDU.oswego.cs.dl.util.concurrent"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../../EDU/oswego/cs/dl/util/concurrent/ClockDaemon.html" title="class in EDU.oswego.cs.dl.util.concurrent"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../../index.html?EDU/oswego/cs/dl/util/concurrent/Channel.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Channel.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
